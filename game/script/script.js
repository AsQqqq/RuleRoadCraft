const gameArea = document.getElementById('gameArea');
const canvas = document.getElementById('canvas');
const canvasContainer = document.getElementById('canvasContainer');
const toolbox = document.getElementById('toolbox');
const BASE_GRID_SIZE = 12.5; // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏ –ø—Ä–∏ zoomLevel = 1
let zoomLevel = 1; // –¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å –∑—É–º–∞ (1 = 100%)
let draggedBlock = null;
let draggedBlocks = []; // For multi-block dragging
let previewBlock = null;
let dragDataFallback = null;
let panOffsetX = 0; // –°–º–µ—â–µ–Ω–∏–µ –ø–æ X –¥–ª—è –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
let panOffsetY = 0; // –°–º–µ—â–µ–Ω–∏–µ –ø–æ Y –¥–ª—è –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
let selectedBlocks = []; // –°–ø–∏—Å–æ–∫ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤

document.addEventListener('contextmenu', function(event) {
    event.preventDefault();
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä—ã –∏–ª–∏ —Å–∫—Ä–∏–ø—Ç–∞
async function checkResource(folder, resourcePath) {
    try {
        const response = await fetch(`assets/${folder}/${resourcePath}`, { method: 'HEAD' });
        return response.ok;
    } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ—Å—É—Ä—Å–∞ ${resourcePath} –≤ –ø–∞–ø–∫–µ ${folder}: ${error.message}`);
        return false;
    }
}

// –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ –ø–∞–ø–æ–∫ –∏–∑ folders.json
async function getFolders() {
    try {
        const response = await fetch('assets/folders.json');
        if (!response.ok) {
            throw new Error(`HTTP –æ—à–∏–±–∫–∞ ${response.status}: –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å folders.json`);
        }
        const data = await response.json();
        if (!Array.isArray(data.folders)) {
            throw new Error('folders.json –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –º–∞—Å—Å–∏–≤ folders');
        }
        console.log('–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏:', data.folders);
        return data.folders;
    } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ folders.json: ${error.message}`);
        return [];
    }
}

// –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞
function loadLogicScript(folder, logicPath) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = `assets/${folder}/${logicPath}`;
        script.async = true;
        script.onload = () => {
            console.log(`–°–∫—Ä–∏–ø—Ç ${logicPath} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –¥–ª—è ${folder}`);
            resolve();
        };
        script.onerror = () => {
            console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–∫—Ä–∏–ø—Ç ${logicPath} –¥–ª—è ${folder}`);
            reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–∫—Ä–∏–ø—Ç ${logicPath}`));
        };
        document.head.appendChild(script);
    });
}

// –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è toolbox
async function initToolbox() {
    // –û—á–∏—Å—Ç–∫–∞ toolbox –ø–µ—Ä–µ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
    toolbox.innerHTML = '';

    // –°–æ–∑–¥–∞–Ω–∏–µ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –º—É—Å–æ—Ä–∫–∏
    const trash = document.createElement('div');
    trash.id = 'trash';
    trash.innerHTML = 'üóëÔ∏è';
    trash.style.display = 'flex';
    trash.style.alignItems = 'center';
    trash.style.justifyContent = 'center';
    toolbox.appendChild(trash);
    console.log('–ú—É—Å–æ—Ä–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ toolbox');

    const folders = await getFolders();
    if (folders.length === 0) {
        console.warn('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–∞–ø–æ–∫ –≤ folders.json');
    }

    for (const folder of folders) {
        try {
            const response = await fetch(`assets/${folder}/config.json`);
            if (!response.ok) {
                console.warn(`config.json –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ assets/${folder}: HTTP ${response.status}`);
                continue;
            }
            const config = await response.json();

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
            if (!config.name || !config.version || !config.width || !config.height || !Array.isArray(config.texture) || config.texture.length === 0) {
                console.warn(`–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π config.json –≤ assets/${folder}: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è`);
                continue;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            let textureValid = true;
            for (const texture of config.texture) {
                if (!(await checkResource(folder, texture))) {
                    console.warn(`–¢–µ–∫—Å—Ç—É—Ä–∞ ${texture} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ assets/${folder}`);
                    textureValid = false;
                    break;
                }
            }
            if (!textureValid) continue;

            // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞ –ª–æ–≥–∏–∫–∏, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
            if (config.logic) {
                if (await checkResource(folder, config.logic)) {
                    try {
                        await loadLogicScript(folder, config.logic);
                        console.info(`–°–∫—Ä–∏–ø—Ç ${config.logic} –∑–∞–≥—Ä—É–∂–µ–Ω –¥–ª—è ${folder}`);
                    } catch (error) {
                        console.warn(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞ ${config.logic} –¥–ª—è ${folder}: ${error.message}`);
                    }
                } else {
                    console.warn(`–°–∫—Ä–∏–ø—Ç ${config.logic} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ assets/${folder}`);
                }
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –±–ª–æ–∫–∞ –¥–ª—è toolbox
            const block = document.createElement('div');
            block.className = 'block';
            block.style.width = `${config.width}px`;
            block.style.height = `${config.height}px`;
            block.draggable = true;
            block.dataset.config = JSON.stringify(config);
            block.dataset.folder = folder;
            if (!block.dataset.config || !block.dataset.folder) {
                console.warn(`–û—à–∏–±–∫–∞: dataset.config –∏–ª–∏ dataset.folder –Ω–µ –∑–∞–¥–∞–Ω—ã –¥–ª—è –±–ª–æ–∫–∞ –≤ ${folder}`);
                continue;
            }
            const img = document.createElement('img');
            img.src = `assets/${folder}/${config.texture[0]}`;
            img.style.width = '100%';
            img.style.height = '100%';
            img.onerror = () => {
                console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É ${config.texture[0]} –¥–ª—è ${folder}`);
                img.src = 'https://via.placeholder.com/50x50/cccccc?text=Error';
            };
            block.appendChild(img);
            toolbox.appendChild(block);
            console.log(`–ë–ª–æ–∫ –¥–ª—è ${folder} –¥–æ–±–∞–≤–ª–µ–Ω –≤ toolbox`);
        } catch (error) {
            console.warn(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∞–ø–∫–∏ assets/${folder}: ${error.message}`);
        }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ –±–ª–æ–∫–∏ –≤ toolbox
    const blockCount = toolbox.querySelectorAll('.block').length;
    if (blockCount === 0) {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'error';
        errorDiv.textContent = '–ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤ assets';
        toolbox.appendChild(errorDiv);
        console.warn('–ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö –±–ª–æ–∫–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ toolbox');
    } else {
        console.log(`–£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ ${blockCount} –±–ª–æ–∫–æ–≤ –≤ toolbox`);
    }
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞ –∏ –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
function updateTransform() {
    const transform = `translate(${panOffsetX}px, ${panOffsetY}px) scale(${zoomLevel})`;
    canvasContainer.style.transform = transform;
    console.log('Applied transform:', transform);
    canvas.style.setProperty('--grid-size', `${BASE_GRID_SIZE * zoomLevel}px`);
    const blocks = canvas.querySelectorAll('.block.draggable');
    blocks.forEach(block => {
        const config = JSON.parse(block.dataset.config || '{"width": 50, "height": 50}');
        block.style.width = `${config.width * zoomLevel}px`;
        block.style.height = `${config.height * zoomLevel}px`;
        const baseLeft = parseFloat(block.dataset.baseLeft || block.style.left || 0);
        const baseTop = parseFloat(block.dataset.baseTop || block.style.top || 0);
        block.style.left = `${baseLeft * zoomLevel}px`;
        block.style.top = `${baseTop * zoomLevel}px`;
    });
}

// –û—á–∏—Å—Ç–∫–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è
function clearSelection() {
    selectedBlocks.forEach(block => block.classList.remove('selected'));
    selectedBlocks = [];
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞, –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è –ª–∏ –¥–≤–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
function rectanglesIntersect(rect1, rect2) {
    return !(rect1.right < rect2.left ||
             rect1.left > rect2.right ||
             rect1.bottom < rect2.top ||
             rect1.top > rect2.bottom);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
gameArea.style.display = 'flex';
initToolbox();
updateTransform();

// –°–æ–∑–¥–∞–Ω–∏–µ –ø—É—Å—Ç–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è drag
const blankImage = new Image();
blankImage.src = 'data:image/gif;base64,R0lGODlkAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞ –∏–ª–∏ –æ—á–∏—Å—Ç–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
canvas.addEventListener('click', (e) => {
    const target = e.target.closest('.block.draggable');
    if (target) {
        if (!e.ctrlKey) {
            clearSelection();
        }
        target.classList.add('selected');
        if (!selectedBlocks.includes(target)) {
            selectedBlocks.push(target);
        }
    } else {
        clearSelection();
    }
});

// Dragstart –¥–ª—è –±–ª–æ–∫–æ–≤ –∏–∑ toolbox
toolbox.addEventListener('dragstart', (e) => {
    let block = e.target;
    if (!block.classList.contains('block')) {
        block = block.closest('.block');
    }
    if (block && block.dataset.config && block.dataset.folder) {
        const dragData = {
            config: block.dataset.config,
            folder: block.dataset.folder,
            isFromCanvas: false
        };
        console.log('Dragstart from toolbox:', dragData);
        try {
            const serializedData = JSON.stringify(dragData);
            console.log('Setting dataTransfer:', serializedData);
            e.dataTransfer.setData('text/plain', serializedData);
            dragDataFallback = dragData;
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ dataTransfer: ${error.message}`);
            dragDataFallback = dragData;
        }
        e.dataTransfer.setDragImage(blankImage, 0, 0);
    } else {
        console.warn('Dragstart failed: no block or invalid dataset', { block });
    }
});

// Dragstart –¥–ª—è –±–ª–æ–∫–æ–≤ –Ω–∞ –∫–∞–Ω–≤–∞—Å–µ
canvas.addEventListener('dragstart', (e) => {
    let block = e.target;
    if (!block.classList.contains('block')) {
        block = block.closest('.block');
    }
    if (block && block.dataset.config && block.dataset.folder) {
        draggedBlock = block;
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º selectedBlocks, –µ—Å–ª–∏ –±–ª–æ–∫ –≤—Ö–æ–¥–∏—Ç –≤ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
        draggedBlocks = selectedBlocks.includes(block) && selectedBlocks.length > 0 ? [...selectedBlocks] : [block];
        const dragData = {
            config: block.dataset.config,
            folder: block.dataset.folder,
            isFromCanvas: true,
            isMultiDrag: draggedBlocks.length > 1
        };
        console.log('Dragstart from canvas:', dragData);
        try {
            const serializedData = JSON.stringify(dragData);
            console.log('Setting dataTransfer:', serializedData);
            e.dataTransfer.setData('text/plain', serializedData);
            dragDataFallback = dragData;
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ dataTransfer: ${error.message}`);
            dragDataFallback = dragData;
        }
        e.dataTransfer.setDragImage(blankImage, 0, 0);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã—Ö –±–ª–æ–∫–æ–≤
        draggedBlocks.forEach(b => b.classList.add('selected'));
    } else {
        console.warn('Dragstart failed: no block or invalid dataset');
    }
});

// Dragover –¥–ª—è –∫–∞–Ω–≤–∞—Å–∞
canvas.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (!dragDataFallback) {
        console.warn('Dragover failed: no data in dragDataFallback');
        return;
    }

    const dragData = dragDataFallback;
    const rect = canvas.getBoundingClientRect();
    const offsetX = ((e.clientX - rect.left) / zoomLevel);
    const offsetY = ((e.clientY - rect.top) / zoomLevel);

    console.log('Dragover on canvas:', {
        dragData: dragData,
        offsetX: offsetX,
        offsetY: offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        rectLeft: rect.left,
        rectTop: rect.top,
        zoomLevel
    });

    if (dragData.config && dragData.folder && !dragData.isFromCanvas) {
        try {
            const config = JSON.parse(dragData.config);
            const folder = dragData.folder;
            const snappedX = Math.round((offsetX - config.width / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
            const snappedY = Math.round((offsetY - config.height / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
            console.log('Updating preview block:', { snappedX, snappedY, config });

            if (!previewBlock) {
                console.log('Creating new preview block');
                previewBlock = document.createElement('div');
                previewBlock.className = 'block preview';
                previewBlock.style.width = `${config.width * zoomLevel}px`;
                previewBlock.style.height = `${config.height * zoomLevel}px`;
                previewBlock.style.position = 'absolute';
                previewBlock.dataset.config = dragData.config;
                previewBlock.dataset.folder = folder;
                const img = document.createElement('img');
                img.src = `assets/${folder}/${config.texture[0]}`;
                img.style.width = '100%';
                img.style.height = '100%';
                img.onerror = () => {
                    console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è ${config.name}`);
                    img.src = 'https://via.placeholder.com/50x50/cccccc?text=Error';
                };
                previewBlock.appendChild(img);
                canvas.appendChild(previewBlock);
            }
            previewBlock.style.left = `${snappedX * zoomLevel}px`;
            previewBlock.style.top = `${snappedY * zoomLevel}px`;
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –±–ª–æ–∫–∞: ${error.message}`);
        }
    } else if (dragData.isFromCanvas) {
        try {
            if (dragData.isMultiDrag && draggedBlocks.length > 0) {
                const mouseBaseX = Math.round(offsetX / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const mouseBaseY = Math.round(offsetY / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const refLeft = parseFloat(draggedBlock.dataset.baseLeft || 0);
                const refTop = parseFloat(draggedBlock.dataset.baseTop || 0);
                draggedBlocks.forEach(block => {
                    const blockConfig = JSON.parse(block.dataset.config || '{"width": 50, "height": 50}');
                    const baseLeft = parseFloat(block.dataset.baseLeft || 0);
                    const baseTop = parseFloat(block.dataset.baseTop || 0);
                    const offsetLeft = baseLeft - refLeft;
                    const offsetTop = baseTop - refTop;
                    const snappedX = mouseBaseX + offsetLeft;
                    const snappedY = mouseBaseY + offsetTop;
                    block.classList.add('preview');
                    block.style.left = `${snappedX * zoomLevel}px`;
                    block.style.top = `${snappedY * zoomLevel}px`;
                });
            } else if (draggedBlock) {
                const blockConfig = JSON.parse(draggedBlock.dataset.config || '{"width": 50, "height": 50}');
                const snappedX = Math.round((offsetX - blockConfig.width / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const snappedY = Math.round((offsetY - blockConfig.height / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                console.log('Moving existing block preview:', { snappedX, snappedY });
                draggedBlock.classList.add('preview');
                draggedBlock.style.left = `${snappedX * zoomLevel}px`;
                draggedBlock.style.top = `${snappedY * zoomLevel}px`;
            }
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è: ${error.message}`);
        }
    } else {
        console.warn('Dragover failed: invalid drag data');
    }
});

// Dragleave –¥–ª—è –∫–∞–Ω–≤–∞—Å–∞
canvas.addEventListener('dragleave', (e) => {
    if (previewBlock && !canvas.contains(e.relatedTarget)) {
        console.log('Removing preview block on dragleave');
        previewBlock.remove();
        previewBlock = null;
    }
});

// Drop –¥–ª—è –∫–∞–Ω–≤–∞—Å–∞
canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!dragDataFallback) {
        console.warn('Drop failed: no data in dragDataFallback');
        return;
    }

    const dragData = dragDataFallback;
    console.log('Drop on canvas:', {
        dragData: dragData,
        offsetX: e.offsetX,
        offsetY: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY
    });

    const rect = canvas.getBoundingClientRect();
    const offsetX = ((e.clientX - rect.left) / zoomLevel);
    const offsetY = ((e.clientY - rect.top) / zoomLevel);

    if (dragData.config && dragData.folder && !dragData.isFromCanvas) {
        try {
            const config = JSON.parse(dragData.config);
            const folder = dragData.folder;
            const snappedX = Math.round((offsetX - config.width / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
            const snappedY = Math.round((offsetY - config.height / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
            console.log('Creating new block:', { snappedX, snappedY, config });

            if (previewBlock) {
                console.log('Converting preview block to permanent');
                previewBlock.className = 'block draggable';
                previewBlock.draggable = true;
                previewBlock.style.left = `${snappedX * zoomLevel}px`;
                previewBlock.style.top = `${snappedY * zoomLevel}px`;
                previewBlock.dataset.baseLeft = snappedX;
                previewBlock.dataset.baseTop = snappedY;
                previewBlock.style.width = `${config.width * zoomLevel}px`;
                previewBlock.style.height = `${config.height * zoomLevel}px`;
                previewBlock = null;
            } else {
                console.log('Creating new block (fallback)');
                const block = document.createElement('div');
                block.className = 'block draggable';
                block.style.width = `${config.width * zoomLevel}px`;
                block.style.height = `${config.width * zoomLevel}px`;
                block.style.left = `${snappedX * zoomLevel}px`;
                block.style.top = `${snappedY * zoomLevel}px`;
                block.style.position = 'absolute';
                block.draggable = true;
                block.dataset.config = dragData.config;
                block.dataset.folder = folder;
                block.dataset.baseLeft = snappedX;
                block.dataset.baseTop = snappedY;
                const img = document.createElement('img');
                img.src = `assets/${folder}/${config.texture[0]}`;
                img.style.width = '100%';
                img.style.height = '100%';
                img.onerror = () => {
                    console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è ${config.name}`);
                    img.src = 'https://via.placeholder.com/50x50/cccccc?text=Error';
                };
                block.appendChild(img);
                canvas.appendChild(block);
            }
            // –û—á–∏—â–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –±–ª–æ–∫–∞
            clearSelection();
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –±–ª–æ–∫–∞: ${error.message}`);
            if (previewBlock) {
                previewBlock.remove();
                previewBlock = null;
            }
        }
    } else if (dragData.isFromCanvas) {
        try {
            if (dragData.isMultiDrag && draggedBlocks.length > 0) {
                const mouseBaseX = Math.round(offsetX / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const mouseBaseY = Math.round(offsetY / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const refLeft = parseFloat(draggedBlock.dataset.baseLeft || 0);
                const refTop = parseFloat(draggedBlock.dataset.baseTop || 0);
                draggedBlocks.forEach(block => {
                    const blockConfig = JSON.parse(block.dataset.config || '{"width": 50, "height": 50}');
                    const baseLeft = parseFloat(block.dataset.baseLeft || 0);
                    const baseTop = parseFloat(block.dataset.baseTop || 0);
                    const offsetLeft = baseLeft - refLeft;
                    const offsetTop = baseTop - refTop;
                    const snappedX = mouseBaseX + offsetLeft;
                    const snappedY = mouseBaseY + offsetTop;
                    block.classList.remove('preview');
                    block.classList.add('selected'); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                    block.style.left = `${snappedX * zoomLevel}px`;
                    block.style.top = `${snappedY * zoomLevel}px`;
                    block.dataset.baseLeft = snappedX;
                    block.dataset.baseTop = snappedY;
                    block.style.width = `${blockConfig.width * zoomLevel}px`;
                    block.style.height = `${blockConfig.height * zoomLevel}px`;
                });
                draggedBlocks = [];
            } else if (draggedBlock) {
                const blockConfig = JSON.parse(draggedBlock.dataset.config || '{"width": 50, "height": 50}');
                const snappedX = Math.round((offsetX - blockConfig.width / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                const snappedY = Math.round((offsetY - blockConfig.height / 2) / BASE_GRID_SIZE) * BASE_GRID_SIZE;
                console.log('Fixing existing block:', { snappedX, snappedY });
                draggedBlock.classList.remove('preview');
                draggedBlock.classList.add('selected'); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                draggedBlock.style.left = `${snappedX * zoomLevel}px`;
                draggedBlock.style.top = `${snappedY * zoomLevel}px`;
                draggedBlock.dataset.baseLeft = snappedX;
                draggedBlock.dataset.baseTop = snappedY;
                draggedBlock.style.width = `${blockConfig.width * zoomLevel}px`;
                draggedBlock.style.height = `${blockConfig.height * zoomLevel}px`;
                draggedBlock = null;
            }
            // –û–±–Ω–æ–≤–ª—è–µ–º selectedBlocks –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            selectedBlocks = [...canvas.querySelectorAll('.block.draggable.selected')];
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –±–ª–æ–∫–∞: ${error.message}`);
        }
    } else {
        console.warn('Drop failed: invalid drag data');
    }
    dragDataFallback = null;
});

// Dragover –¥–ª—è toolbox
toolbox.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (e.target.id === 'trash') {
        e.target.classList.add('dragover');
    }
});

// Drop –¥–ª—è toolbox (—É–¥–∞–ª–µ–Ω–∏–µ –≤ –º—É—Å–æ—Ä–∫—É)
toolbox.addEventListener('drop', (e) => {
    e.preventDefault();
    if (e.target.id === 'trash') {
        console.log('Removing block(s) via trash');
        e.target.classList.remove('dragover');
        if (draggedBlocks.length > 0) {
            draggedBlocks.forEach(block => block.remove());
            draggedBlocks = [];
            clearSelection();
        } else if (draggedBlock) {
            draggedBlock.remove();
            draggedBlock = null;
            clearSelection();
        }
        if (previewBlock) {
            previewBlock.remove();
            previewBlock = null;
        }
    }
    dragDataFallback = null;
});


// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à Delete –∏–ª–∏ Backspace –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤
document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –±—Ä–∞—É–∑–µ—Ä–∞
        const selected = canvas.querySelectorAll('.block.draggable.selected');
        if (selected.length > 0) {
            console.log(`–£–¥–∞–ª–µ–Ω–∏–µ ${selected.length} –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤`);
            selected.forEach(block => block.remove());
            clearSelection(); // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ selectedBlocks
        }
    }
});